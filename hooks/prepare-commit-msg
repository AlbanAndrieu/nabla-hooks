#!/usr/bin/env python3
import atexit
import os
import shutil
import subprocess
import sys
import traceback
from pathlib import Path

from get_msg import match_msg
from termcolor import colored

try:
    from colorama import init
    from termcolor import colored

    # use Colorama to make Termcolor work on Windows too
    init()
except ImportError as error:
    print("could not import colorama:")
    print(error)
    exit(1)

try:
    from commitizen.cz.utils import get_backup_file_path
except ImportError as error:
    print("could not import commitizen:")
    print(error)
    exit(1)


# Collect the parameters
commit_msg_filepath = sys.argv[1]
if len(sys.argv) > 2:
    commit_type = sys.argv[2]
else:
    commit_type = ""
if len(sys.argv) > 3:
    commit_hash = sys.argv[3]
else:
    commit_hash = ""

# print('prepare-commit-msg: File: {}\nType: {}\nHash: {}'.format(
#     commit_msg_filepath,
#     commit_type,
#     commit_hash,
# ))


def clean_all(commit_msg_filepath: str = "./.git/COMMIT_EDITMSG"):
    # print('Registered cleanAll with {}'.format(commit_msg_filepath))

    filename = os.path.expanduser(commit_msg_filepath)

    if os.path.exists(filename):
        os.remove(commit_msg_filepath)
        print(colored("File {} removed!".format(commit_msg_filepath), "yellow"))


atexit.register(clean_all, commit_msg_filepath)


def podmena(commit_msg_filepath, enable=False):
    if enable:
        curdir = os.path.dirname(os.path.realpath(__file__))
        with open(os.path.join(curdir, "database.txt")) as f:
            emoji = f.readlines()

        with open(commit_msg_filepath) as f:
            text = f.read()

        with open(commit_msg_filepath, "w") as f:
            # f.write('{} :{}:'.format(text.strip(), random.choice(emoji).strip()))
            f.write("{} :{}:".format(text.strip(), os.urandom(emoji).strip()))


def prepare_commit_msg(commit_msg_file: str) -> int:
    # Check if commit message already has content (e.g., from oco/opencommit or manual entry)
    try:
        with open(commit_msg_file, "r") as f:
            existing_content = f.read().strip()
            # Filter out comments (lines starting with # after stripping whitespace)
            non_comment_lines = [
                line
                for line in existing_content.split("\n")
                if not line.lstrip().startswith("#")
            ]
            existing_message = "\n".join(non_comment_lines).strip()
    except FileNotFoundError:
        existing_message = ""

    # If there's already a commit message (e.g., from oco/opencommit), validate it
    if existing_message:
        # check if the existing commit message is valid using commitizen
        exit_code = subprocess.run(
            [
                "cz",
                "check",
                "--commit-msg-file",
                commit_msg_file,
            ],
            check=False,
            capture_output=True,
        ).returncode
        if exit_code == 0:
            return 0
        # If not valid with commitizen, still allow it - commit-msg hook will validate
        print(
            colored(
                "⚠️  Existing commit message detected (possibly from oco/opencommit). Skipping commitizen generation.",
                "yellow",
            ),
        )
        return 0

    # No existing message, check if we should use a backup
    backup_file = Path(get_backup_file_path())
    if backup_file.is_file():
        # confirm if commit message from backup file should be reused
        answer = input("retry with previous message? [y/N]: ")
        if answer.lower() == "y":
            shutil.copyfile(backup_file, commit_msg_file)
            return 0

    # use commitizen to generate the commit message
    exit_code = subprocess.run(
        [
            "cz",
            "commit",
            "--dry-run",
            "--write-message-to-file",
            commit_msg_file,
        ],
        check=False,
        stdin=sys.stdin,
        stdout=sys.stdout,
    ).returncode
    if exit_code:
        return exit_code

    # write message to backup file
    shutil.copyfile(commit_msg_file, backup_file)
    return 0


if __name__ == "__main__":
    # make hook interactive by attaching /dev/tty to stdin
    with open("/dev/tty") as tty:
        sys.stdin = tty
        exit_code = prepare_commit_msg(sys.argv[1])
        exit(exit_code)
